# Javascript(2)

---

## 作用域

当代码在一个环境中执行时，会创建变量对象的一个作用域链，可以保证对执行环境有权访问的所有变量和函数的有序访问，在作用域链的前端，始终都是当前执行代码所在环境的变量对象。如果查找不到某个变量，则逐级向上查找，直到找到第一个变量。

js没有块级作用域只有函数级作用域

## 垃圾收集

* 标记清除:对于进入函数作用域的变量会被标记为进入环境，而当执行完函数后，变量会被标记为离开环境，js会自动收集处理这些变量（一定时间间隔处理一次，循环执行）

* 引用计数：指的是跟踪每个值被引用的次数，多一次引用就加一，引用被覆盖就减一，知道减为零，会被收集

由于有标记清除机制，所以函数作用域的变量会自动处理，而全局的变量需要我们手动处理，比如给不用的变量赋值为null。

## 引用类型

### Object

创建Object实例有两种方法

```javascript
var p = new Object(); p.name = "bin";
var p = {name:"bin"};
```

object实例访问属性有两种方法

```javascript
p.name
p["name"]
```

### Array

#### 创建数组

```javascript
var arr = new Array() //参数为数字则是定义长度，其他数据类型，则是定义项
var arr = [1,2,3]
```

#### 检测数组

* 使用instance操作符，但是对于多框架的情况下，有多个Array构造函数，所以不可靠
* Array.isArray(val)，比较适合

#### 转换方法

* toString()会返回数组每一项以字符串形式拼接而成的以逗号分隔的字符串
* valueof()还是会返回数组
* join()方法，可是使数组转化成，以参数分隔的字符串，如果没有参数，或者参数使undefined，那么将用逗号分隔

#### 栈方法

LIFO

* push():用于将任意参数添加到数组末尾，返回新数组长度
* pop():删除数组最后一项，返回删除项

#### 队列方法

FIFO

* unshift():将任意多项添加到数组前面，返回新数组长度
* shift():删除数组第一项，返回删除项

#### 重排序方法

* reverse()用于将数组倒置
* sort()可以使数组升序排列，不过它调用的是数组每项的toString()方法，所以数字比较是编码值，导致不准确，可以传递一个参数
    ```javascript
    funtion(value1,value2){
        if(value1 < value2){
            return -1;
        }else if(value1 > value2){
            return 1;
        }else{
            return 0;
        }
    }
    对于纯数字比较，可以使用
    function(value1,value2){
        return value1 - value2;
    }
    ```

#### 操作方法

* contact()方法:接受项或者数组，拼接在数组后面，返回新数组。如果不传参数，则返回数组的一个副本
* slice():用于截取数组，接受两个参数，从第一个参数的索引开始，到第二个参数索引结束（不包括），如果不传第二个参数，会一直截取到最后一项
* splice():接受三个及以上参数，第一个为起始索引，第二个为删除数目，第三个及以上为插入项。（改变原数组）

#### 位置方法

* indexOf():接受两参数，第一个是查找项，第二个（可选）是开始查找的位置，没找到则返回-1
* lastIndexOf():反向查找，接受两参数，第一个是查找项，第二个（可选）是开始查找的位置，没找到则返回-1

#### 迭代方法

以下每个方法都接受两个参数，一个是处理函数，另一个（可选，是作用域this）。另外处理函数都可以接受三个参数，第一个是数组项，第二个是该项的索引，第三个是原数组

```javascript
every():对数组每一项运行指定函数，如果每一项都返回true，则返回true

some():对数组每一项运行制定函数，如果有一项返回true，则返回true

filter():对数组每一项运行指定函数，返回该函数返回true的项，组成的数组

forEach():对数组每一项执行指定函数，没有返回值

map():对数组每一项运行制定函数，返回函数返回结果组成的数组
```

#### 归并方法

* reduce和reduceRight，都接受两个参数，一个是每一项上调用的函数，另一个是起始值。函数接受四个参数，依此是
  * 前一个值
  * 当前值
  * 项的索引
  * 数组对象

### Date类型

日期实例使用Date()构造函数来实例化

参数是毫秒数，不传入参数，创建的对象是当前时间的对象。

有两个方法可以转化日期为毫秒数

* Date.parse()接受字符串参数(实际上直接传递给Date构造函数字符串，也会调用Date.parse()方法)
  * 月/日/年，如11/21/2017
  * 英文月名 日,年
  * 英文星期 英文月 日 年 时:分:秒 时区
  * YYYY-MM-DDTHH:mm:ss.sssZ
* Date.UTC():参数为年份、基于0的月份、月中的哪一天、小时数、分钟、秒、毫秒数。只有年月是必须的其余省略，都会被设为0(Date()构造函数也接受UTC格式的参数，它是基于本地时区的)
  * Date.UTC(2017,10,24,17,20,20,100) //2017-11-24 17:20:20

Date.now()方法返回的是调用这个方法的日期和时间的毫秒数

Date的实例同样有toString()、toLocaleString()、valueOf()方法，可以直接比较两个时间的大小，因为valueOf()会把实例转化为毫秒数

常用实例方法

```js
getTime():获取毫秒数

getFullYear():获取四位数年份

getMonth():获取基于0的月份

getDate():返回日期月份中的天数

getDay():返回日期中的星期几

getHours():基于0的小时数

getMinutes():基于0的分钟数

getSeconds():返回日期中的秒数

getMilliseconds():返回日期中的毫秒数
```

### RegExp类型

#### 创建

* 字面量：var expression = /pattern/flags
  * pattern为任意正则表达式
  * flags为标志，包括：
    * g(global)：全局模式
    * i(case-insensitive)：不区分大小写
    * m(multiline)：多行模式
* 构造函数：var expression = new RegExp("pattern,"flags")

注意：元字符需要转义：(),[],{},\,^,$,|,?,*,+,.（构造函数模式则需要双重转义）

#### 实例属性

```javascript
global：是否设置了g标志

ignoreCasw：是否设置了i标志

lastIndex：表示开始搜索下一个匹配项的字符位置

multiline：是否设置了m标志

source：正则表达式的字符串表示（按字面量形式）
```

#### 实例方法

* exec()：接受一个参数，即应用模式的字符串。返回一个数组，数组第一项是与整个模式匹配的字符串，其他项则是与模式捕获组匹配的字符串。另外，这个数组有两个属性
  * input：表示应用正则表达式的字符串
  * index：表示匹配项在字符串中的位置
  * 如果模式有g标志，那么再次使用exec方法会从上次匹配位置开始
* test()：接受字符串参数，如果模式与参数匹配，返回true，否则返回false。

### Function类型

ECMAScript函数实际上是对象，因此每个函数都是函数Function类型的实例，都有属性和方法，因此函数名实际上也是一个指向函数对象的指针，不会与函数绑定。（这也就是为什么没有重载）

#### 定义函数的方法

```js
//函数声明
function name(){

}
//函数表达式
var fun = function(){

}
//函数实例
var fun = new Function('param1','param2','statement')
```

函数声明和函数表达式的唯一差别就是，函数声明会提前，使其在任何代码之前可以使用。

#### 函数内部属性

在函数内部有arguments和this两个特殊的对象

arguments对象是是一个类数组，数组项是函数的参数

arguments对象还有一个callee属性，它指向拥有这个arguments对象的函数。

this引用的就是函数执行的环境对象

另外，还有一个函数对象的属性，这个属性保存着调用当前函数的引用，如果是在全局作用域中调用，它的值是null

例如：arguments.callee.caller

#### 函数属性和方法

* 每个函数都有两个属性
  * prototype：原型对象
  * length：希望接受命名参数的个数
* 每个函数都包含两个非继承而来的方法，都是用于在特定作用域调用函数
  * apply()：第一个参数是作用域。第二个参数是参数数组
  * call()： 第一个参数是作用域。后面的参数是一一列举出来的

另外，ECMAScript 5还定义了一个方法：bind()，他接收一个参数，即作用域对象

这个方法将创建一个函数的实例，并不直接执行

### 基本包装类型

这种类型是指在基本类型值调用方法和属性，经历了以下过程：

1. 创建相应构造函数的实例
1. 在实例上调用指定的方法
1. 销毁实例

所以与引用类型相比，基本类型的包装类型，生命周期短。

也可以显式的调用Boolean、Number、String来创建包装类型的对象。但是应该尽量避免使用这种方法。

一是，很难与引用类型值区分。二是，typeof操作符验证基本包装类型实例会返回object。

下面介绍不同的基本包装类型实例包含的方法

#### Boolean

重写了toString方法，返回"true","false".也重写了valueOf方法，返回true,false

#### Number

同样重写了toString和valueOf方法

另外还有

* toFixed()方法：指定小数点后位数，如果少于原数字，则会舍入
* toExponential()方法：返回指数表示法，同样接受一个参数，同样为指定小数位数
* toPrecisions()方法：参数为所有数字位数（不包含指数部分）

#### String

String类型每个实例都有一个length属性，表示字符串中包含多少字符（双字节字符也是一个），该类型提供了很多方法

* 字符方法:两个方法都接受一个参数，即基于0的位置
  * charAt():返回该位置字符
  * charCodeAt():返回该位置字符编码
* 字符串操作方法
  * concat():用于将一个或多个字符串拼接起来，返回新的字符串
  * slice():接受两个参数，一个是字符串的开始位置，二是最后一个字符串最后一个字符的后面位置
  * substr():接受两个参数，一个是字符串的开始位置，二是返回的字符个数
  * substring():接受两个参数，一个是字符串的开始位置，二是最后一个字符串最后一个字符的后面位置

对于负数，slice()方法，会将负数与字符串长度相加，substr()将负的第一个参数加上字符串长度，负的第二个参数转化为0，substring()会把所有负参数转化为0

* 字符串位置方法：都接受两个参数，一是给定字符串，二是开始位置
  * indexof():正向
  * lastIndexOf():反向
* trim():创建字符串副本，删除前置和后缀空格
* 字符串大小写转换
  * toLowerCase():转换为小写
  * toLocaleLowerCase():特定地区的实现
  * toUpperCase():转换为大写
  * toLocaleUpperCase():特定地区的实现
* 字符串匹配模式
  * match():接受一个参数，即正则表达式或者RegExp对象，返回一个数组，第一项是匹配字符串，之后为捕获组匹配的字符串
  * search():接受参数同上，返回第一个匹配项的索引，没有匹配项返回-1
  * replace():接受两个参数，第一个参数同上或者是字符串（不会被转换为正则表达式），第二个参数可以是一个字符串，或者函数
    * 只有一个匹配项的情况下，会传递三个参数，模式的匹配项、模式匹配项的位置、原始字符串
    * 在有多个捕获组的情况下，第二到n个参数为捕获组匹配项，最后两个参数仍为模式匹配项和原始字符串
  * split():可以基于指定的分隔符将一个字符串分割成多个字符串，并将结果放置到一个数组中，第一个参数为字符串或者正则表达式，也可接受第二个参数，指定数组的大小。这样，返回的数组不会超过指定大小
* localeCompare():用于比较两个字符串，返回正数、0、负数
* fromCharCode():接收多个字符编码，返回字符串
  * 例如 String.fromCharCode(101,102,103)

### 单体内置对象

单体内置对象的定义是，由ECMAScript实现提供的，不依赖于宿主环境对象，这些对象在ECMAScript程序执行之前就已经存在了。例如Object、Array、String

ECMA-262还定义了两个单体内置对象Global和Math

* Global对象：在全局作用域定义的函数和属性都是Global对象的属性
  * URI编码方法
    * encodeURI():可以对URI进行编码，不会对本身属于URI的特殊字符进行编码
    * encodeURIComponent():会对它发现的任何非标准字符编码
  *解码方法对应的是:
    * decodeURI()
    * decodeURIComponent()
  * eval():JS解析器，接受一个参数，即要执行的js代码字符串
  * window对象：web浏览器是将全局对象作为window对象的一部分加以实现的，因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性

* Math对象：保存着数学公式和信息
  * Math.PI等
  * min(),max():可以用来挑选出参数中的最大最小值
    * 如果要找出数组中的最大最小值可以使用
      ```javascript
      var max = Math.max.apply(Math,values)
      ```
* 舍入方法
  * Math.ceil():执行向上舍入
  * Math.floor():执行向下舍入
  * Math.round():执行标准舍入
* random():返回大于等于0小于1的一个随机数。
  * 从某个整数范围内随机选择一个值
    ```javascript
    值 = Math.floor(Math.random()*可能值的总数+第一个可能的值)
    ```
* 其他方法：如Math.abs()

## 未完待续 ^_^